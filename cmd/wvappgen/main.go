/*
wvappgen - Webview Binding Generator

This tool automatically generates JavaScript/TypeScript bindings and Go registration functions
for Go structs and their methods, enabling seamless communication between Go and Webview.

Usage:
    wvappgen [flags]

Flags:
    -t, --type string        Output file type: "js" for Webview, "es6" for ES6 modules, "ts" for TypeScript (default "js")
    -o, --output string      Output file path for JavaScript/TypeScript bindings
    -go, --go-output string  Output file path for Go binding functions
    -pkg, --package string   Go package name for generated bindings (default "main")
    -f, --file string        Go source file to parse (default ".")

Features:
- Automatically detects exported structs and their exported methods
- Generates type-safe parameter handling and validation
- Supports multiple structs with distinct naming
- Ignores structs marked with "//wvappgen:skip" comment

Example struct that will be processed:
    type UserService struct {
        id int
    }
    func (u *UserService) GetID() int { return u.id }

Example struct that will be ignored:
    //wvappgen:skip
    type InternalService struct {
        secret string
    }
    func (i *InternalService) GetSecret() string { return i.secret }

Generated JavaScript binding example:
    const UserService = {};
    UserService.GetID = function() {
        return goCall('go_main_UserService_GetID', []);
    };

Generated Go binding example:
    func RegisterUserServiceBindings(instance *UserService) {
        wvapp.UserFunctionRegistry["go_main_UserService_GetID"] = func(ctx context.Context, wv *wvapp.Webview, args []any) (any, error) {
            result := instance.GetID()
            return result, nil
        }
    }
*/

package main

import (
	"flag"
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"log"
	"os"
	"path/filepath"
	"strings"
)

// generateES6Header generates ES6 module header
func generateES6Header(output *strings.Builder, sourceFile string) {
	output.WriteString("// Code generated by wvappgen. DO NOT EDIT.\n")
	output.WriteString("// Source file: " + sourceFile + "\n\n")
	output.WriteString("/* eslint-disable */\n\n")
	output.WriteString("// ES6 Module for Webview bindings\n")
	output.WriteString("// Assumes goCall function is available globally\n\n")
}

// generateWebviewHeader generates Webview compatible header
func generateWebviewHeader(output *strings.Builder, sourceFile string) {
	output.WriteString("// Code generated by wvappgen. DO NOT EDIT.\n")
	output.WriteString("// Source file: " + sourceFile + "\n\n")
	output.WriteString("/* eslint-disable */\n\n")
	output.WriteString("// Webview JavaScript bindings\n")
	output.WriteString("// Assumes goCall function is available globally\n\n")
}

// generateTypeScriptHeader generates TypeScript module header
func generateTypeScriptHeader(output *strings.Builder, sourceFile string) {
	output.WriteString("// Code generated by wvappgen. DO NOT EDIT.\n")
	output.WriteString("// Source file: " + sourceFile + "\n\n")
	output.WriteString("/* eslint-disable */\n\n")
	output.WriteString("// TypeScript definitions for Webview bindings\n")
	output.WriteString("// Assumes goCall function is available globally\n\n")
	output.WriteString("declare global {\n")
	output.WriteString("  function goCall(method: string, args: any[]): Promise<any>;\n")
	output.WriteString("}\n\n")
}

// generateGoHeader generates Go package header
func generateGoHeader(output *strings.Builder, packageName, sourceFile string) {
	output.WriteString("// Code generated by wvappgen. DO NOT EDIT.\n")
	output.WriteString("// Source file: " + sourceFile + "\n\n")
	output.WriteString("package " + packageName + "\n\n")
	output.WriteString("import (\n")
	output.WriteString("\t\"context\"\n")
	output.WriteString("\t\"fmt\"\n\n")
	output.WriteString("\t\"github.com/millken/wvapp\"\n")
	output.WriteString(")\n\n")
}

// processStructMethods processes all methods for a given struct
func processStructMethods(node *ast.File, structName, jsStructName string, jsOutput, goOutput *strings.Builder, fileType, goOutputFile string, structFunctions *map[string]bool) {
	var hasGoFunction bool

	// Find methods for this struct
	for _, mDecl := range node.Decls {
		funcDecl, isFunc := mDecl.(*ast.FuncDecl)
		if !isFunc {
			continue
		}

		if funcDecl.Recv == nil || len(funcDecl.Recv.List) == 0 {
			continue // Not a method
		}

		// Check receiver type
		recvField := funcDecl.Recv.List[0]
		var recvTypeName string
		// Handle both pointer (*T) and value (T) receivers
		if starExpr, isPointerRecv := recvField.Type.(*ast.StarExpr); isPointerRecv {
			if ident, isIdent := starExpr.X.(*ast.Ident); isIdent {
				recvTypeName = ident.Name
			}
		} else if ident, isIdent := recvField.Type.(*ast.Ident); isIdent {
			recvTypeName = ident.Name
		}

		if recvTypeName != structName {
			continue // Method for a different struct
		}

		if !funcDecl.Name.IsExported() {
			continue // Skip unexported methods
		}

		// Generate Go function header if this is the first method
		if goOutputFile != "" && !hasGoFunction {
			goOutput.WriteString(fmt.Sprintf("// Register%sBindings registers all bindings for %s with the wvapp\n", structName, structName))
			goOutput.WriteString(fmt.Sprintf("func Register%sBindings(instance *%s) {\n", structName, structName))
			(*structFunctions)[structName] = true
			hasGoFunction = true
		}

		methodName := funcDecl.Name.Name

		var jsParamsList []string
		var jsArgsForGoCall []string
		var goParamTypes []string // Track Go parameter types for type assertions

		if funcDecl.Type.Params != nil {
			paramIndex := 0
			for _, field := range funcDecl.Type.Params.List {
				// Get the type information
				var typeStr string
				if field.Type != nil {
					switch t := field.Type.(type) {
					case *ast.Ident:
						typeStr = t.Name
					case *ast.SelectorExpr:
						if x, ok := t.X.(*ast.Ident); ok {
							typeStr = x.Name + "." + t.Sel.Name
						}
					default:
						typeStr = "any{}" // fallback
					}
				}

				if len(field.Names) > 0 {
					for _, nameIdent := range field.Names {
						jsParamsList = append(jsParamsList, nameIdent.Name)
						jsArgsForGoCall = append(jsArgsForGoCall, nameIdent.Name)
						goParamTypes = append(goParamTypes, typeStr)
					}
				} else {
					// Handle anonymous parameters like func(int, string)
					pName := fmt.Sprintf("p%d", paramIndex)
					jsParamsList = append(jsParamsList, pName)
					jsArgsForGoCall = append(jsArgsForGoCall, pName)
					goParamTypes = append(goParamTypes, typeStr)
					paramIndex++
				}
			}
		}

		jsParamsStr := strings.Join(jsParamsList, ", ")
		jsArgsArrayStr := "[" + strings.Join(jsArgsForGoCall, ", ") + "]"
		if len(jsArgsForGoCall) == 0 {
			jsArgsArrayStr = "[]" // Ensure it's an empty array string for goCall
		}

		// Convention for Go binding name: "go_<package>_<struct_name>_<method_name>"
		packageName := node.Name.Name // Get the actual package name from AST
		goBindingName := fmt.Sprintf("go_%s_%s_%s", packageName, structName, methodName)

		// Check if method has return values
		hasReturn := funcDecl.Type.Results != nil && len(funcDecl.Type.Results.List) > 0

		// Generate JavaScript/TypeScript binding
		if fileType == "ts" {
			// Build parameter types for TypeScript
			var tsParamsList []string
			for i, param := range jsParamsList {
				paramType := goParamTypes[i]
				var tsType string
				switch paramType {
				case "int", "int32", "int64", "float32", "float64":
					tsType = "number"
				case "string":
					tsType = "string"
				case "bool":
					tsType = "boolean"
				default:
					tsType = "any"
				}
				tsParamsList = append(tsParamsList, fmt.Sprintf("%s: %s", param, tsType))
			}
			tsParamsStr := strings.Join(tsParamsList, ", ")

			// Add implementation to namespace
			jsOutput.WriteString(fmt.Sprintf("  export function %s(%s): Promise<any> {\n", methodName, tsParamsStr))
			jsOutput.WriteString(fmt.Sprintf("    return goCall('%s', %s);\n", goBindingName, jsArgsArrayStr))
			jsOutput.WriteString("  }\n\n")
		} else {
			jsOutput.WriteString(fmt.Sprintf("%s.%s = function(%s) {\n", jsStructName, methodName, jsParamsStr))
			if hasReturn {
				jsOutput.WriteString(fmt.Sprintf("    return goCall('%s', %s, true);\n", goBindingName, jsArgsArrayStr))
			} else {
				jsOutput.WriteString(fmt.Sprintf("    return goCall('%s', %s);\n", goBindingName, jsArgsArrayStr))
			}
			jsOutput.WriteString("};\n\n")
		}

		// Generate Go binding code if requested
		if goOutputFile != "" {
			goOutput.WriteString(fmt.Sprintf("\twvapp.UserFunctionRegistry[\"%s\"] = func(ctx context.Context, wv *wvapp.Webview, args []any) (any, error) {\n", goBindingName))

			// Generate parameter extraction and type assertions
			if len(jsParamsList) > 0 {
				goOutput.WriteString(fmt.Sprintf("\t\tif len(args) < %d {\n", len(jsParamsList)))
				goOutput.WriteString(fmt.Sprintf("\t\t\treturn nil, fmt.Errorf(\"insufficient arguments for %s.%s, expected %d, got %%d\", len(args))\n", structName, methodName, len(jsParamsList)))
				goOutput.WriteString("\t\t}\n\n")

				// Generate type assertions based on Go types
				for i, param := range jsParamsList {
					goType := goParamTypes[i]

					// Generate appropriate type assertion based on Go type
					switch goType {
					case "int", "int32", "int64":
						goOutput.WriteString(fmt.Sprintf("\t\t%s, ok := args[%d].(float64) // JSON numbers come as float64\n", param, i))
						goOutput.WriteString("\t\tif !ok {\n")
						goOutput.WriteString(fmt.Sprintf("\t\t\treturn nil, fmt.Errorf(\"argument %d (%s) must be a number\")\n", i, param))
						goOutput.WriteString("\t\t}\n")
						goOutput.WriteString(fmt.Sprintf("\t\t%sInt := %s(%s)\n", param, goType, param))
					case "string":
						goOutput.WriteString(fmt.Sprintf("\t\t%s, ok := args[%d].(string)\n", param, i))
						goOutput.WriteString("\t\tif !ok {\n")
						goOutput.WriteString(fmt.Sprintf("\t\t\treturn nil, fmt.Errorf(\"argument %d (%s) must be a string\")\n", i, param))
						goOutput.WriteString("\t\t}\n")
					case "bool":
						goOutput.WriteString(fmt.Sprintf("\t\t%s, ok := args[%d].(bool)\n", param, i))
						goOutput.WriteString("\t\tif !ok {\n")
						goOutput.WriteString(fmt.Sprintf("\t\t\treturn nil, fmt.Errorf(\"argument %d (%s) must be a boolean\")\n", i, param))
						goOutput.WriteString("\t\t}\n")
					case "float32", "float64":
						goOutput.WriteString(fmt.Sprintf("\t\t%s, ok := args[%d].(float64)\n", param, i))
						goOutput.WriteString("\t\tif !ok {\n")
						goOutput.WriteString(fmt.Sprintf("\t\t\treturn nil, fmt.Errorf(\"argument %d (%s) must be a number\")\n", i, param))
						goOutput.WriteString("\t\t}\n")
						if goType == "float32" {
							goOutput.WriteString(fmt.Sprintf("\t\t%sFloat := float32(%s)\n", param, param))
						}
					default:
						// Generic type assertion for other types
						goOutput.WriteString(fmt.Sprintf("\t\t%s := args[%d] // Type: %s (generic)\n", param, i, goType))
					}
				}
				goOutput.WriteString("\n")
			}

			// Generate the actual method call with proper parameter names
			// Check if method has return values
			hasReturn := funcDecl.Type.Results != nil && len(funcDecl.Type.Results.List) > 0

			if len(jsParamsList) > 0 {
				// Build the parameter list using the converted names
				var callParams []string
				for i, param := range jsParamsList {
					goType := goParamTypes[i]
					switch goType {
					case "int", "int32", "int64":
						callParams = append(callParams, param+"Int")
					case "float32":
						callParams = append(callParams, param+"Float")
					default:
						callParams = append(callParams, param)
					}
				}

				if hasReturn {
					goOutput.WriteString(fmt.Sprintf("\t\tresult := instance.%s(%s)\n", methodName, strings.Join(callParams, ", ")))
					goOutput.WriteString("\t\treturn result, nil\n")
				} else {
					goOutput.WriteString(fmt.Sprintf("\t\tinstance.%s(%s)\n", methodName, strings.Join(callParams, ", ")))
					goOutput.WriteString("\t\treturn nil, nil\n")
				}
			} else {
				if hasReturn {
					goOutput.WriteString(fmt.Sprintf("\t\tresult := instance.%s()\n", methodName))
					goOutput.WriteString("\t\treturn result, nil\n")
				} else {
					goOutput.WriteString(fmt.Sprintf("\t\tinstance.%s()\n", methodName))
					goOutput.WriteString("\t\treturn nil, nil\n")
				}
			}
			goOutput.WriteString("\t}\n\n")
		}
	}

	// Close the Go function if we created one
	if goOutputFile != "" && hasGoFunction {
		goOutput.WriteString("}\n\n")
	}

	// Close TypeScript namespace if we're generating TypeScript
	if fileType == "ts" {
		jsOutput.WriteString("}\n\n")
	}
}

// checkIgnoreComment checks if the given struct should be ignored based on comments
func checkIgnoreComment(genDecl *ast.GenDecl) bool {
	if genDecl.Doc != nil {
		for _, comment := range genDecl.Doc.List {
			if strings.Contains(comment.Text, "wvappgen:skip") {
				return true
			}
		}
	}
	return false
}

func main() {
	outputFile := flag.String("o", "", "Output file (e.g., service.js or service.ts)")
	fileType := flag.String("t", "js", "File type: 'js' for Webview, 'es6' for ES6 modules, 'ts' for TypeScript")
	goOutputFile := flag.String("go", "", "Go output file for bindings (e.g., bindings.go)")
	packageName := flag.String("pkg", "main", "Go package name for generated bindings")
	flag.Parse()

	if *outputFile == "" {
		log.Fatal("Error: -o output_file flag is required.")
	}

	if *fileType != "js" && *fileType != "es6" && *fileType != "ts" {
		log.Fatal("Error: -t must be 'js', 'es6', or 'ts'")
	}

	goFile := os.Getenv("GOFILE")
	if goFile == "" {
		log.Fatal("Error: GOFILE environment variable not set. This tool is intended to be run via 'go generate'.")
	}
	// goPackage := os.Getenv("GOPACKAGE") // May be useful for more complex scenarios

	fset := token.NewFileSet()
	node, err := parser.ParseFile(fset, goFile, nil, parser.ParseComments)
	if err != nil {
		log.Fatalf("Error parsing Go file %s: %v", goFile, err)
	}

	var jsOutput strings.Builder
	var goOutput strings.Builder

	// Generate header based on file type
	if *fileType == "ts" {
		generateTypeScriptHeader(&jsOutput, filepath.Base(goFile))
	} else if *fileType == "es6" {
		generateES6Header(&jsOutput, filepath.Base(goFile))
	} else {
		generateWebviewHeader(&jsOutput, filepath.Base(goFile))
	}

	// Generate Go header if requested
	if *goOutputFile != "" {
		generateGoHeader(&goOutput, *packageName, filepath.Base(goFile))
	}

	// Assumption: goCall, _resolveWebviewPromise, _rejectWebviewPromise are defined
	// in the environment where this generated script will run

	structsProcessed := make(map[string]bool)
	var exportedStructs []string             // Track structs for ES6 exports
	structFunctions := make(map[string]bool) // Track which structs have generated functions

	for _, fDecl := range node.Decls {
		// Find struct type declarations
		genDecl, ok := fDecl.(*ast.GenDecl)
		if !ok || genDecl.Tok != token.TYPE {
			continue
		}

		// Check if this declaration should be ignored
		if checkIgnoreComment(genDecl) {
			continue
		}

		for _, spec := range genDecl.Specs {
			typeSpec, ok := spec.(*ast.TypeSpec)
			if !ok {
				continue
			}

			// Check if it's a struct type
			_, isStruct := typeSpec.Type.(*ast.StructType)
			if !isStruct {
				continue
			}

			structName := typeSpec.Name.Name
			// Convention: JS object name preserves the original Go struct name casing
			jsStructName := structName

			if !structsProcessed[structName] {
				exportedStructs = append(exportedStructs, jsStructName)
				if *fileType == "ts" {
					// For TypeScript, we'll generate namespace directly with implementation
					jsOutput.WriteString(fmt.Sprintf("export namespace %s {\n", jsStructName))
					// Methods will be added during processStructMethods
				} else {
					// Generate ES6 object
					jsOutput.WriteString(fmt.Sprintf("// --- Bindings for Go struct '%s' ---\n", structName))
					jsOutput.WriteString(fmt.Sprintf("const %s = {};\n\n", jsStructName))
				}

				// Process methods for this struct
				processStructMethods(node, structName, jsStructName, &jsOutput, &goOutput, *fileType, *goOutputFile, &structFunctions)

				structsProcessed[structName] = true
			}
		}
	}
	// Add exports at the end (if generating JS/ES6)
	if (*fileType == "js" || *fileType == "es6") && len(exportedStructs) > 0 {
		if *fileType == "es6" {
			// ES6 Module exports only - no global variables
			jsOutput.WriteString("// ES6 Module exports\n")
			jsOutput.WriteString("export {\n")
			for i, structName := range exportedStructs {
				if i == len(exportedStructs)-1 {
					jsOutput.WriteString(fmt.Sprintf("  %s\n", structName))
				} else {
					jsOutput.WriteString(fmt.Sprintf("  %s,\n", structName))
				}
			}
			jsOutput.WriteString("};\n\n")
			jsOutput.WriteString("// Default export (for convenience)\n")
			if len(exportedStructs) == 1 {
				jsOutput.WriteString(fmt.Sprintf("export default %s;\n", exportedStructs[0]))
			} else {
				jsOutput.WriteString("export default {\n")
				for i, structName := range exportedStructs {
					if i == len(exportedStructs)-1 {
						jsOutput.WriteString(fmt.Sprintf("  %s\n", structName))
					} else {
						jsOutput.WriteString(fmt.Sprintf("  %s,\n", structName))
					}
				}
				jsOutput.WriteString("};\n")
			}
		} else {
			// js mode - only global variables for Webview environment
			jsOutput.WriteString("// Global variables for Webview environment\n")
			for _, structName := range exportedStructs {
				jsOutput.WriteString("if (typeof window !== 'undefined') {\n")
				jsOutput.WriteString(fmt.Sprintf("  window.%s = %s;\n", structName, structName))
				jsOutput.WriteString("} else if (typeof global !== 'undefined') {\n")
				jsOutput.WriteString(fmt.Sprintf("  global.%s = %s;\n", structName, structName))
				jsOutput.WriteString("}\n")
			}
		}
	}

	// Write JavaScript/TypeScript file
	err = os.WriteFile(*outputFile, []byte(jsOutput.String()), 0644)
	if err != nil {
		log.Fatalf("Error writing to output file %s: %v", *outputFile, err)
	}

	// Write Go file if requested
	if *goOutputFile != "" {
		err = os.WriteFile(*goOutputFile, []byte(goOutput.String()), 0644)
		if err != nil {
			log.Fatalf("Error writing to Go output file %s: %v", *goOutputFile, err)
		}
		fmt.Printf("Successfully generated Go bindings in %s\n", *goOutputFile)
	}

	fmt.Printf("Successfully generated bindings in %s (from %s)\n", *outputFile, goFile)
}
